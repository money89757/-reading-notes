getpid();获取当前进程的进程号  
getppid();获取当前进程的父进程号  

exit() 退出进程(可以刷新缓存区)  
_ exit() 退出进程(不能刷新缓存区)  
参数:EXIT_SUCCESS EXIT_FAILURE  

exec函数族:需要在一个进程空间中执行另一个功能时  
execl("/bin/命令","命令名称","选项","参数"，NULL); 会覆盖掉原有进程的代码段，数据段，堆栈等空间。  

wait();  
wa
itpid();  
这两个函数一定是使用在父进程中。基本作用是：等待子进程退出，如果子进程退出则唤醒wait函数，并且回收子进程资源(task_struct)  

### 守护进程的创建过程:
1. 创建子进程，父进程退出
	 孤儿进程是后台进程，满足了守护进程是后台的基本特点。
2. 调用setsid()函数，创建新的会话  
	 会话包含多个进程组，进程组包含了多个进程。对于一个会话来说，有且仅有一个进程组是前台的。  

3. 修改权限掩码 umask(0)  
4. 修改工作路径 chdir();  
5. 删除之间继承的文件描述符  
   我们可以通过getdtablesize()函数知道子进程从父进程继承了多少个文件描述符  

```C
   fd_max = getdtablesize();
   for(fd = 0;fd < fd_max;fd ++)
		close(fd);
```

6. 要有无限循环

### 线程
1. 轻量级进程――所谓的轻量级线程其实是一个可以拥有时间片的函数  
2. 线程的特点:因为使用线程可以避免进程上下文的切换造成系统开销大的问题  
   不同的线程之间可以共享了进程的资源的。线程也有独立的资源。  

3. 线程哪些资源独立，哪些资源共享
```
共享的资源:静态数据，工作路径，信号操作函数，线程外的栈空间共享的(进程中打开的文件描述符)，线程外的堆空间是共享的
独立资源:线程ID，线程相关寄存器,线程内部的栈空间是独立的。线程内的堆是独立的

注意:进程消亡，线程不复存在。

```

### 线程的接口:
#### 创建线程函数:
```C
pthread_create(pthread_t *id,const pthread_attr_t *,void *(*p)(void *),void *);
参数1:指向了存放线程id的空间
参数2:线程属性，几乎用不到。传NULL
参数3:函数指针，这个指针指向了线程函数      所谓的线程是p指向的空间
参数4:给线程函数传参			

```
```C
自定义abc的函数原型: void *abc(void *x) 这里的x接收参数4传递的地址
调用pthread_create(,,abc,);

```

##### 编译线程代码:gcc main.c -lpthread

pthread_join();//如果指定的线程不退出则阻塞，当指定的线程结束时会被唤醒。  

```C
例子://假设主进程中打开了一个1.txt文件。
	 //换种方法:分别在两个线程里打开1.txt文件
	 定义一个全局变量flag = 0;
	 线程1:从1.txt文件中读取数据，打印到终端
	 while(1)
	 {
		想办法在这里阻塞while(!flag);
		读文件
		打印到终端
	 }
	 线程2:从终端读取数据，打印到1.txt文件中
	 while(1)
	 {
		读终端
			如果从终端读取到了quit字符串则退出当前线程
		写入文件
		想办法告诉线程1，前面的阻塞可以唤醒了。flag = 1;
	 }

```

#### 线程的资源是可以共享的。		
sem_init(代表了资源种类,0,某种资源的个数); 初始化资源――从操作系统获取一些资源的个数  
sem_wait(资源的种类); 申请资源――如果能申请到则将初始化的资源-1，如果申请不到则阻塞。也叫做P操作  
sem_post(资源种类);不会阻塞，如果释放成功会将初始化的资源+1。 叫做V操作  
