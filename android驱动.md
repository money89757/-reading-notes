# 安卓驱动 #

 ## DAY1 #
---
1. Java 和 C 语言交互 jin 
  lib + 库名+.so  --- >  libxxx.so  
 
    1.1 编写Java程序  

        public class HelloWorld{

            static {
                System.LoadLibaray("native");
                /静态块 自动加载
            }

            public native void text();
            //本地方法 native 修饰 没有方法体，方法体放在名为xxx的动态库中。(libnative.so)
        }
        
    1.2 通过Javac 编译Java程序

    1.3 通过Javah 生成jni 接口

    1.4 实现jni接口

    1.5 将c文件生成动态库 

         gcc xxx.c  -shared -fPIC -o libxxx.so -I /usr/lib/jvm/java-7-openjdk-amd64/include/
    
    1.6 设置库的搜索路径

        export LD_LIBRARY_PATH=.

    1.7 运行 javac程序
      
---
2. jni接口  

    javah就是产生jni接口的   
    
```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloWorld */

#ifndef _Included_HelloWorld
#define _Included_HelloWorld
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloWorld
 * Method:    text
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloWorld_text
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif

```

上述程序中

```
JNIEXPORT void JNICALL Java_HelloWorld_hello(JNIEnv *, jobject);

#define JNIEXPORT 是个空的宏，标识作用__init 

void 返回值类型和native 方法是一致的

#define JNICALL 是个空的宏 ，标识作用

```
3. jni_OnLoad(JavaVM *jvm,void *reserved)
```
{
    1.初始化jnienv getenv()
    2.找到相应的类
    3.注册registernative jninativemethod结构体(这个结构体绑定了本地的方法名和函数)
}
```

4. JNINativeMethod
```
 typedef struct {  
    char *name;         本地方法的名字         
    char *signature;    本地方法的签名               
    void *fnPtr;         本地函数入口地址     
  } JNINativeMethod;
```
---
## 程序历程1 ##

HelloWorld.java
```
public class HelloWorld
{
	
	static 
	{
		System.loadLibrary("global");
	}

	public native void text();

	public static void main (String [] args)
	{
		/* code */
		HelloWorld a = new HelloWorld();
		a.text();
	}
	
}

```

HelloWorld.h

```

/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloWorld */

#ifndef _Included_HelloWorld
#define _Included_HelloWorld
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloWorld
 * Method:    text
 * Signature: ()V          ->...>签名
 */                        
JNIEXPORT void JNICALL Java_HelloWorld_text
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif

```
native.c

```
#include "Hello.h"

JNIEXPORT jint JNICALL Java_Hello_globam(JNIEnv *ent, jobject obj,jchar i)

{
	int j;
	j = i;
	printf("num = %d\n",i);
	//printf("Hello world\n");
	return 250;
}

```

---

## 程序历程2 ->open/close/ioctl ##

1. HelloWorld.java

```
public class HelloWorld {

	static 
	{
		System.loadLibrary("bob");
	}

	public native int open();
	public native void close(int fd);
	public native int ioctl(int fd,int cmd,long arg);

	public static void main (String [] args)
	{
		/* code */
		int fd;
		int cmd = 1;
		long arg = 2;

		HelloWorld b = new HelloWorld();
	
		fd = b.open();
		b.close(fd);
		b.ioctl(fd,cmd,arg);
	}
	
}

```

2. HelloWorld.h
```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloWorld */

#ifndef _Included_HelloWorld
#define _Included_HelloWorld
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloWorld
 * Method:    open
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_HelloWorld_open
  (JNIEnv *, jobject);

/*
 * Class:     HelloWorld
 * Method:    close
 * Signature: (I)V
 */
JNIEXPORT void JNICALL Java_HelloWorld_close
  (JNIEnv *, jobject, jint);

/*
 * Class:     HelloWorld
 * Method:    ioctl
 * Signature: (IIJ)I
 */
JNIEXPORT jint JNICALL Java_HelloWorld_ioctl
  (JNIEnv *, jobject, jint, jint, jlong);

#ifdef __cplusplus
}
#endif
#endif
```

3. Native.c
```
#include <jni.h>

jint jopen(JNIEnv *env,jobject obj)
{
	printf("open success\n");
}

void jclose(JNIEnv *env,jobject obj,jint fd)
{
	printf("close success\n");
}

jint jioctl(JNIEnv *env,jobject obj,jint fd,jint cmd,jlong arg)
{
	printf("ioctl success\n");
}

JNINativeMethod method[]= 
{
	"open","()I",(void *)jopen,
	"close","(I)V",(void *)jclose,
	"ioctl","(IIJ)I",(void *)jioctl,
};

jint JNI_OnLoad(JavaVM *jvm, void *reserved)
{

	JNIEnv *env;
	jclass jcls;
	if((*jvm)->GetEnv(jvm,(void **)&env,JNI_VERSION_1_2))
	{
		return JNI_ERR;
	}

	jcls = (*env)->FindClass(env,"HelloWorld");

	if(jcls == NULL)
	{
		return JNI_ERR;
	}
	
	(*env) -> RegisterNatives(env,jcls,method,sizeof(method)/sizeof(JNINativeMethod));

	return JNI_VERSION_1_2;
}
```
## 程序历程 ->打开文件 ##
1. TestJni.java
```
public class TestJni 
{
	static 
	{
		System.loadLibrary("native");
	}
	

	public native String hello(String str);

	public static void main (String [] args)
	{
		/* code */

		TestJni J = new TestJni();

		System.out.println(J.hello("/dev/null"));//打开文件的路径
	}
}

```
2. TestJni.h
```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class TestJni */

#ifndef _Included_TestJni
#define _Included_TestJni
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     TestJni
 * Method:    hello
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_TestJni_hello
  (JNIEnv *, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif

```

3. Native.c
```
#include <jni.h>

jstring jhello(JNIEnv *env,jobject obj , jstring propmt)
{
	const char *str;
	
	char *p = "hello";
	str = (*env)->GetStringUTFChars(env,propmt,NULL);

	if(str == NULL)
	{
		return 0;
	}
	printf("open success\n");
	printf("str = %s\n",str);
	
	(*env)->ReleaseStringUTFChars(env,propmt,str);

	return (*env)->NewStringUTF(env,p);
}


JNINativeMethod method[]= 
{
	"hello","(Ljava/lang/String;)Ljava/lang/String;",(void *)jhello,
};

jint JNI_OnLoad(JavaVM *jvm, void *reserved)
{

	JNIEnv *env;
	jclass jcls;
	if((*jvm)->GetEnv(jvm,(void **)&env,JNI_VERSION_1_2))
	{
		return JNI_ERR;
	}

	jcls = (*env)->FindClass(env,"TestJni");

	if(jcls == NULL)
	{
		return JNI_ERR;
	}
	
	(*env) -> RegisterNatives(env,jcls,method,sizeof(method)/sizeof(JNINativeMethod));

	return JNI_VERSION_1_2;
}
```
## 程序历程 ->打开数组 ##
1. TestJni.java
```
public class TestJni 
{
	static 
	{
		System.loadLibrary("hello");
	}

	private native int hello(int[]arr);

	public static void main (String [] args)
	{
		/* code */
		int[]arr = {1,3,2,4,8,6,10};
		TestJni j = new TestJni();
		System.out.println(j.hello(arr));
	 }
}
```

2. TestJni.h
```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class TestJni */

#ifndef _Included_TestJni
#define _Included_TestJni
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     TestJni
 * Method:    hello
 * Signature: ([I)I
 */
JNIEXPORT jint JNICALL Java_TestJni_hello
  (JNIEnv *, jobject, jintArray);

#ifdef __cplusplus
}
#endif
#endif
```

3. Native.c
```
#include <jni.h>

jint jhello(JNIEnv *env,jobject obj , jintArray arr)
{
	jint *carr;
	jint i,sum = 0;
	carr = (*env)->GetIntArrayElements(env,arr,NULL);
	if(carr == NULL)
	{
		return 0;
	}
	for(i = 0;i < 7;i++)
	{
		printf("number %d is %d\n",i+1,carr[i]);
		sum += carr[i];
	}
	(*env)->ReleaseIntArrayElements(env,arr,carr,0);
	return sum;
}

JNINativeMethod method[]= 
{
	"hello","([I)I",(void *)jhello,
};

jint JNI_OnLoad(JavaVM *jvm, void *reserved)
{

	JNIEnv *env;
	jclass jcls;
	if((*jvm)->GetEnv(jvm,(void **)&env,JNI_VERSION_1_2))
	{
		return JNI_ERR;
	}

	jcls = (*env)->FindClass(env,"TestJni");

	if(jcls == NULL)
	{
		return JNI_ERR;
	}
	
	(*env) -> RegisterNatives(env,jcls,method,sizeof(method)/sizeof(JNINativeMethod));

	return JNI_VERSION_1_2;
}

```
## 通过以上代码，总结规律，假设用Jni实现一个经典的HelloWorld程序，该程序在java中通过JNI调用C函数“HelloWorld”的步骤是 ##

1. 创建一个Java程序（HelloWorld.java）定义原生的c/c++函数。  
    创建java文件，声明native方法

2. 用javac编译HelloWorld.java生成HelloWorld.class。  
    编译java文件javac HelloWorld.java 

3. 用javah带-jni参数编译HelloWorld.class生成HelloWorld.h文       件，该文件中定义了c的函数原型。在实现c函数的时候需要。  
    生成头文件　javah -jni HelloWorld　会生成HelloWorld.h文件

4. 创建HelloWorld.c，实现HelloWorld.h定义的函数。  
    根据HelloWorld.h文件创建c文件，并实现方法  
    注意：  
    
    1. 需要将jni.h和jni_md.h拷贝至工程目录下 
    2. 将HelloWorld.h文件中的#include <jni.h>系统应用改为　#include "jni.h"
    3. 补全方法参数（env , obj），完成c代码的实现

5. 编译HelloWorld.c生成libHelloWorld.so。  
    执行如下命令：
    
    ```
    gcc -I/usr/lib/jvm/java-6-sun/include/linux/ -I/usr/lib/jvm/java-6-sun/include/ -I/home/user/Downloads/JNITest/AAA -fPIC -shared -o libHelloWorld.so HelloWorld.c  
    ```
    参数解释  
    -shared:该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件。  
    -fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。  
    -I/usr/lib/jvm/java-6-sun/include/linux/ : 表示在编译HelloWorld.c时，将此目录作为第一个寻找头文件的目录。   

    注意：  
    ```
    　　编译完成的库文件名称(eg:libHelloWorld.so)必须命名格式为：（libxxx.so） , 加载动态库时格式如下：  
    加载动态库  
    static{  
        System.loadLibrary("xxx");  //不需要加lib字段，直接加载xxx即可  
    }  
    ```
---

# Day2 #

---
执行命令  
linux@ubuntu:~/fspad_733/androidL$ ls  
得到一堆文件,其中最重要的文件有

>frameworks

>system  
    Android根文件系统相关源码，如：init、adb、toolbox及一些库

>Build
    build目录中存放的是编译系统mk文件，编译规则和generic产品基础配置文件

>hardware
    主要是硬件适配层HAL代码

>out
    编译完成后的代码输出与此目录

>device 
    设备相关代码

## 编译Android系统 ##

>在linux@ubuntu:~/fspad_733/androidL$ 当前目录执行  
1. source build/envsetup.sh配置环境变量
2. lunch 加载分支(当时选择7)
```
You're building on Linux

Lunch menu... pick a combo:
     1. aosp_arm-eng
     2. aosp_arm64-eng
     3. aosp_mips-eng
     4. aosp_mips64-eng
     5. aosp_x86-eng
     6. aosp_x86_64-eng
     7. fspad_733-eng //华清开发板的模式
     8. fspad_733-user
```
3. make -j8(-j8代表多进程编译，看性能)

## m,mm与mmm ##
m编译全部  
mm只编译当前目录  
mmm编译指定目录  
以上必须执行编译androidL后才能实现  

## Android.mk内容 ##
> LOCAL_PATH:=$(call my-dir) 获取当前路径  

> include $(CLEAR_VARS) 清空除了LOCAL_PATH之外的环境变量

> LOCAL_SRC_FILES:=1.c 编译需要的源文件  

> LOCAL_MODULE:= test 生成的目标 

> LOCAL_MODULE_TAGS:=eng 版本类型  

```
user：只有在user版本时该模块才被编译进去；
eng：只有在eng版本时该模块才被编译进去；
test：只有在tests版本时该模块才被编译进去；
optional：在所有版本中都编译该模块进去。
```
> LOCAL_MODULE_PATH:=$(LOCAL_PATH) 目标的存放路径   

> include $(BUILD_EXECUTABLE)  目标的类  

> LOCAL_LDFLAGS := -L/Path –lxxx  
> -I 跟上头文件的目录 , -L 跟上库的目录 ,-l 库的名字 比如 -lm  -lsqlite3  -lpthread